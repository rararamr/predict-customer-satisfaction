import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
import joblib
import shap
from collections import OrderedDict
from datetime import datetime

def predict_customer_rating(shopid, orderid, itemid, userid, ctime, model_name='Decision Tree'):
    try:
        suffix = '_rf' if model_name == 'Random Forest' else '_dt'
        pipeline = joblib.load(f'{model_name.lower().replace(" ", "_")}.pkl')
        model = pipeline.named_steps['classifier']  # Extract classifier from pipeline
        scaler = joblib.load(f'scaler{suffix}.pkl')
        encoders = joblib.load(f'label_encoders{suffix}.pkl')
        training_stats = joblib.load(f'training_stats{suffix}.pkl')
        
        # Create DataFrame with single row
        input_data = pd.DataFrame({
            'shopid': [shopid],
            'orderid': [orderid],
            'itemid': [itemid],
            'userid': [userid],
            'ctime': [ctime]
        })

        # Track feature transformations for explanation
        feature_changes = OrderedDict()
        unseen_features = 0
        
        for col in ['shopid', 'orderid', 'itemid', 'userid']:
            try:
                original_value = input_data[col].values[0]
                input_data[col] = encoders[col].transform(input_data[[col]].values.ravel())[0]
                feature_changes[col] = f"Original: {original_value}"
            except ValueError:
                feature_changes[col] = f"Unseen value, using median"
                input_data[col] = training_stats[col]['median']
                unseen_features += 1
                
        # Create time-based features
        dt = pd.to_datetime(input_data['ctime'], unit='s')
        input_data['month'] = dt.dt.month
        input_data['week'] = dt.dt.isocalendar().week
        input_data['day'] = dt.dt.day
        input_data['weekday'] = dt.dt.weekday
        input_data['week_of_year'] = dt.dt.strftime('%U').astype(int)
        # Add season feature (0 = June-November, 1 = December-May)
        input_data['season'] = 1 - ((input_data['month'] >= 6) & (input_data['month'] <= 11)).astype(int)

        # Check if transaction is near sale
        sale_timestamps = [
            1633046400, 1633132800, 1633219200, 1633305600, 1633392000, 1633478400, 1633564800, 1633651200, 1633737600, 1633824000, 1635120000, 1635206400, 1635292800, 1635379200, 1635465600, 1635552000, 1635638400, 1635724800, 1635811200, 1635897600, 1635984000, 1636070400, 1636156800, 1636243200, 1636329600, 1636416000, 1636502400, 1636588800, 1636675200, 1636761600, 1636848000, 1636934400, 1637712000, 1637798400, 1637884800, 1637971200, 1638057600, 1638144000, 1638230400, 1638316800, 1638403200, 1638489600, 1638576000, 1638662400, 1638748800, 1638835200, 1638921600, 1639008000, 1639094400, 1639180800, 1639267200, 1639353600, 1639440000, 1639526400, 1640649600, 1640736000, 1640822400, 1640908800, 1640995200, 1641081600, 1643500800, 1643587200, 1643673600, 1643760000, 1643846400, 1646265600, 1646352000, 1646438400, 1646524800, 1646611200, 1646697600, 1646784000, 1646870400, 1646956800, 1647043200, 1647129600, 1647216000, 1647302400, 1648339200, 1648425600, 1648512000, 1648598400, 1648684800, 1648771200, 1648857600, 1648944000, 1649030400, 1649116800, 1649203200, 1651104000, 1651190400, 1651276800, 1651363200, 1651449600, 1651536000, 1651622400, 1651708800, 1653609600, 1653696000, 1653782400, 1653868800, 1653955200, 1654041600, 1654128000, 1654214400, 1654300800, 1654387200, 1654473600, 1654560000, 1654646400, 1656460800, 1656547200, 1656633600, 1656720000, 1656806400, 1656892800, 1656979200, 1657065600, 1657152000, 1656633600, 1656720000, 1656806400, 1656892800, 1656979200, 1657065600, 1657152000, 1657238400, 1657324800, 1659312000, 1659398400, 1659484800, 1659571200, 1659657600, 1659744000, 1659830400, 1659916800, 1660003200, 1660089600, 1661472000, 1661558400, 1661644800, 1661731200, 1661817600, 1661904000, 1661990400, 1662076800, 1662163200, 1662249600, 1662336000, 1662422400, 1662508800, 1662595200, 1662681600, 1662768000, 1662854400, 1664582400, 1664668800, 1664755200, 1664841600, 1664928000, 1665014400, 1665100800, 1665187200, 1665273600, 1665360000, 1665446400, 1665532800, 1666915200, 1667001600, 1667088000, 1667174400, 1667260800, 1667347200, 1667433600, 1667520000, 1667606400, 1667692800, 1667779200, 1667865600, 1667952000, 1668038400, 1668124800, 1668211200, 1668297600, 1669852800, 1669939200, 1670025600, 1670112000, 1670198400, 1670284800, 1670371200, 1670457600, 1670544000, 1670630400, 1670716800, 1670803200, 1670889600, 1670976000, 1671062400, 1672358400, 1672444800, 1672531200, 1674691200, 1674777600, 1674864000, 1674950400, 1675036800, 1675123200, 1675209600, 1675296000, 1675382400, 1675468800, 1677196800, 1677283200, 1677369600, 1677456000, 1677542400, 1677628800, 1677715200, 1677801600, 1677888000, 1677974400, 1678060800, 1678147200, 1678233600, 1678320000, 1678406400, 1678492800, 1678579200, 1678665600, 1678752000, 1678838400, 1679875200, 1679961600, 1680048000, 1680134400, 1680220800, 1680307200, 1680393600, 1680480000, 1680566400, 1680652800, 1680739200, 1682899200, 1682985600, 1683072000, 1683158400, 1683244800, 1683331200, 1685577600, 1685664000, 1685750400, 1685836800, 1685923200, 1686009600, 1686096000, 1688342400, 1688428800, 1688515200, 1688601600, 1688688000, 1688774400, 1691107200, 1691193600, 1691280000, 1691366400, 1691452800, 1691539200, 1693526400, 1693612800, 1693699200, 1693785600, 1693872000, 1693958400, 1694044800, 1694131200, 1694217600, 1694304000, 1696118400, 1696204800, 1696291200, 1696377600, 1696464000, 1696550400, 1696636800, 1696723200, 1696809600, 1696896000, 1696982400, 1697068800, 1698796800, 1698883200, 1698969600, 1699056000, 1699142400, 1699228800, 1699315200, 1699401600, 1699488000, 1699574400, 1699660800, 1699747200, 1699833600, 1701388800, 1701475200, 1701561600, 1701648000, 1701734400, 1701820800, 1701907200, 1701993600, 1702080000, 1702166400, 1702252800, 1702339200, 1703894400, 1703980800, 1704067200, 1706745600, 1706832000, 1706918400, 1709424000, 1709510400, 1709596800, 1709683200, 1709769600, 1709856000, 1709942400, 1710028800, 1710115200, 1710201600, 1710288000, 1710374400, 1710460800, 1711900800, 1711987200, 1712073600, 1712160000, 1712246400, 1713974400, 1714060800, 1714147200, 1714233600, 1714320000, 1714406400, 1714492800, 1714579200, 1714665600, 1714752000, 1714838400, 1714924800, 1717171200, 1717257600, 1717344000, 1717430400, 1717516800, 1717603200, 1717689600, 1717776000, 1717862400, 1717948800, 1718035200, 1718121600, 1718208000, 1718294400, 1718380800, 1718467200, 1718553600, 1718640000, 1718726400, 1718812800, 1718899200, 1718985600, 1719072000, 1719158400, 1719244800, 1719331200, 1719417600, 1719504000, 1719590400, 1719676800, 1719763200, 1719849600, 1719936000, 1720022400, 1720108800, 1720195200, 1720281600, 1720368000, 1722700800, 1722787200, 1722873600, 1722960000, 1723046400, 1723132800, 1725120000, 1725206400, 1725292800, 1725379200, 1725465600, 1725552000, 1725638400, 1725724800, 1725811200, 1725897600, 1727625600, 1727712000, 1727798400, 1727884800, 1727971200, 1728057600, 1728144000, 1728230400, 1728316800, 1728403200, 1728489600, 1728576000, 1730217600, 1730304000, 1730390400, 1730476800, 1730563200, 1730649600, 1730736000, 1730822400, 1730908800, 1730995200, 1731081600, 1731168000, 1731254400, 1731340800, 1731427200, 1731513600, 1731600000, 1731686400, 1731772800, 1731859200, 1731945600, 1732032000, 1732118400, 1732204800, 1732291200, 1732377600, 1732464000, 1732550400, 1732636800, 1732723200, 1732809600, 1732896000, 1732982400, 1733068800, 1733155200, 1733241600, 1733328000, 1733414400, 1733500800, 1733587200, 1733673600, 1733760000, 1733846400, 1733932800, 1734019200, 1734105600, 1734192000
        ]
        tolerance = 259200
        sale_timestamps_array = np.array(sale_timestamps)
        input_data['sale'] = 1 if np.any(np.abs(sale_timestamps_array - ctime) <= tolerance) else 0

        # Select features in correct order
        features = ['shopid', 'orderid', 'itemid', 'userid', 'month', 
                    'week', 'day', 'weekday', 'week_of_year', 'sale', 'season']
        X = input_data[features]

        # Only transform, don't fit
        X_scaled = scaler.transform(X)
        # Make prediction
        prediction = pipeline.predict(X_scaled)[0]
        
        # Generate SHAP explanation
        explainer = shap.TreeExplainer(model)
        shap_values = explainer.shap_values(X_scaled)
        
        # Convert numpy values to native Python types
        if isinstance(shap_values, list):
            shap_values = shap_values[0]
        shap_values = shap_values.flatten()
            
        # Create feature importance dict with converted values
        feature_importance = dict(zip(features, np.abs(shap_values)))
        sorted_importance = dict(sorted(feature_importance.items(), 
                                      key=lambda x: abs(x[1]), 
                                      reverse=True))
        
        # Build explanation text
        explanation = [f"Predicted Rating: {int(prediction)} stars\n"]
        explanation.append("Key factors:")
        
        for feature, importance in sorted_importance.items():
            value = float(X[feature].values[0])
            if feature in feature_changes:
                explanation.append(f"â€¢ {feature}: {feature_changes[feature]} (Impact: {importance:.2f})")
            else:
                explanation.append(f"â€¢ {feature}: {value:.2f} (Impact: {importance:.2f})")

        return int(prediction), "\n".join(explanation)

    except Exception as e:
        print(f"Error during prediction: {str(e)}")
        return None, f"Error generating prediction and explanation{str(e)}"

